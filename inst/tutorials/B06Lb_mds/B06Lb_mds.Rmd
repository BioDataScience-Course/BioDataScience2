---
title: "Positionnement multidimensionnel (MDS)"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD II Module 6** RÃ©aliser et analyser un positionnement multidimensionnel (MDS)."
tutorial:
  id: "B06Lb_mds"
  version: 2.0.1/8
output:
  learnr::tutorial:
  progressive: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience2::learnr_setup()

# mds for SciViews, version 1.0.0
# Copyright (c) 2020-2021, Philippe Grosjean (phgrosjean@sciviews.org)

SciViews::R()
library(broom)

# function mds for several multidimensional scaling functions ------
mds <- function(dist, k = 2, type = c("metric", "nonmetric", "cmdscale",
"wcmdscale", "sammon", "isoMDS", "monoMDS", "metaMDS"), p = 2, ...) {
  type <- match.arg(type)
  res <- switch(type,
    metric = ,
    wcmdscale = structure(vegan::wcmdscale(d = dist, k = k, eig = TRUE, ...),
      class = c("wcmdscale", "mds", "list")),
    cmdscale = structure(stats::cmdscale(d = dist, k = k, eig = TRUE, ...),
      class = c("cmdscale", "mds", "list")),
    nonmetric = ,
    metaMDS = structure(vegan::metaMDS(comm = dist, k = k, ...),
      class = c("metaMDS", "monoMDS", "mds", "list")),
    isoMDS = structure(MASS::isoMDS(d = dist, k = k, ...),
      class = c("isoMDS", "mds", "list")),
    monoMDS = structure(vegan::monoMDS(dist = dist, k = k, ...),
      class = c("monoMDS", "mds", "list")),
    sammon = structure(MASS::sammon(d = dist, k = k, ...),
      class = c("sammon", "mds", "list")),
    stop("Unknown 'mds' type ", type)
  )
  # For non-metric MDS, we add also data required for the Shepard plot
  if (type %in% c("nonmetric", "sammon", "isoMDS", "monoMDS", "metaMDS"))
    res$Shepard <- MASS::Shepard(d = dist, x = res$points, p = p)
    res
}
class(mds) <- c("function", "subsettable_type")

# plot.mds : MDS2 ~ MDS1 --------------------------------
plot.mds <- function(x, y, ...) {
  points <- tibble::as_tibble(x$points, .name_repair = "minimal")
  colnames(points) <- paste0("mds", 1:ncol(points))
  
  plot(data = points, mds2 ~ mds1,...)
}

autoplot.mds <- function(object, labels, ...) {
  points <- tibble::as_tibble(object$points, .name_repair = "minimal")
  colnames(points) <- paste0("mds", 1:ncol(points))
  
  if (!missing(labels)) {
    if (length(labels) != nrow(points))
      stop("You must provide a character vector of length ", nrow(points),
        " for 'labels'")
    points$.labels <- labels
    chart::chart(points, mds2 ~ mds1 %label=% .labels, ...) +
      geom_point() +
      ggrepel::geom_text_repel() +
      coord_fixed(ratio = 1)
  } else {# Plot without labels
    chart::chart(points, mds2 ~ mds1, ...) +
      geom_point() +
      coord_fixed(ratio = 1)
  }
}

chart.mds <- function(data, labels, ..., type = NULL, env = parent.frame())
  autoplot(data, labels = labels, type = type, ...)

shepard <- function(dist, mds, p = 2)
  structure(MASS::Shepard(d = dist, x = mds$points, p = p),
    class = c("shepard", "list"))

plot.shepard <- function(x, y, l.col = "red", l.lwd = 1,
xlab = "Observed Dissimilarity", ylab = "Ordination Distance", ...) {
  she <- tibble::as_tibble(x, .name_repair = "minimal")
  
  plot(data = she, y ~ x, xlab = xlab, ylab = ylab, ...)
  lines(data = she, yf ~ x, type = "S", col = l.col, lwd = l.lwd)
}

autoplot.shepard <- function(object, alpha = 0.5, l.col = "red", l.lwd = 1,
xlab = "Observed Dissimilarity", ylab = "Ordination Distance", ...) {
  she <- tibble::as_tibble(object)
  
  chart(data = she, y ~ x) +
    geom_point(alpha = alpha) +
    geom_step(chart::f_aes(yf ~ x), direction = "vh", col = l.col, lwd = l.lwd) +
    labs(x = xlab, y = ylab)
}

chart.shepard <- function(data, alpha = 0.5, l.col = "red", l.lwd = 1,
xlab = "Observed Dissimilarity", ylab = "Ordination Distance", ..., type = NULL,
env = parent.frame())
  autoplot(data, alpha = alpha, l.col = l.col, l.lwd = l.lwd,
    xlab = xlab, ylab = ylab, type = type, ...)

# augment.mds -------------------------------------------
augment.mds <- function(x, data, ...){
  points <- as_tibble(x$points)
  colnames(points) <- paste0(".mds", 1:ncol(points))
  bind_cols(data, points)
}

# glance.mds -------------------------------------------
glance.mds <- function(x, ...){
  if ("GOF" %in% names(x)) {# Probably cmdscale() or wcmdscale() => metric MDS
    tibble::tibble(GOF1 = x$GOF[1], GOF2 = x$GOF[2])
  } else {# Non metric MDS
    # Calculate linear and non linear R^2 from the Shepard (stress) plot
    tibble::tibble(
      linear_R2 = cor(x$Shepard$y, x$Shepard$yf)^2,
      nonmetric_R2 = 1 - sum(vegan::goodness(x)^2)
    )
  }
}

# dissimilarity ----------------------------------------

# dist is really a dissimilarity matrix => we use dissimilarity() as in the
# {cluster} package, i.e., class is c("dissimilarity", "dist")
# TODO: also make a similarity object and convert between the two
# fun can be stats::dist, vegan::vegdist, vegan::designdist, cluster::daisy
# factoextra::get_dist and probably other dist-compatible functions
# Depending on method =, use either vegan::vegdist or stats::dist as default fun
dissimilarity <- function(data, formula = ~ ., subset = NULL,
  method = "euclidean", scale = FALSE, rownames.col = "rowname",
  transpose = FALSE, fun = NULL, ...) {
  # TODO: get more meaningful warnings and errors by replacing fun by actual
  # name of the function
  if (is.null(fun)) {# Default function depends on the chosen method
    if (method %in% c("maximum", "binary", "minkowski")) {
      fun <- stats::dist
    } else {
      fun <- vegan::vegdist # Note: euclidean/manhattan/canberra in both, but
      # we prioritize vegdist, and canberra is not calculated the same in dist!
    }
  }
  # We accept only formulas with right-hand side => length must be two
  if (length(formula) == 3)
    stop("The formula cannot have a left-hand term")

  # With matrices, we don't use rownames.col: rownames are already correctly set
  if (!is.matrix(data)) {# row names may be in a column (usual for tibbles)
    data <- as.data.frame(data)
    if (rownames.col %in% names(data)) {
      rownames(data) <- data[[rownames.col]]
      data[[rownames.col]] <- NULL
    } else {# rownames.col is NOT used
      rownames.col <- NULL
    }
    if (as.character(formula[2] != ".")) {
      # Subset the columns
      data <- model.frame(formula, data = data, subset = subset)
    } else if (!is.null(subset)) {
      data <- data[subset, ]
    }
  } else {# A matrix
    rownames.col <- NULL
    if (as.character(formula[2] != ".")) {
      # Subset the columns (and possibly the rows)
      if (is.null(subset)) {
        data <- data[, all.vars(formula)]
      } else {
        data <- data[subset, all.vars(formula)]
      }
    }
  }

  if (isTRUE(transpose))
    data <- t(data)

  # Arguments method =/metric = and stand = not always there
  if (!is.null(as.list(args(fun))$metric)) {# metric = instead of method =
    dst <- fun(data, metric = method, stand = scale, ...)
  } else if (isTRUE(scale)) {
    if (is.null(as.list(args(fun))$stand)) {# fun has no stand = argument
      data <- scale(data)
      dst <- fun(data, method = method, ...)
    } else {# We don't standardise ourself because there may be also qualitative
      # or binary data (like for cluster::daisy, for instance)
      dst <- fun(data, method = method, stand = scale, ...)
    }
  } else {# Just method = and scale = FALSE
    dst <- fun(data, method = method, ...)
  }
  attr(dst, "call") <- match.call()
  # Depending if it is a dist or dissimilarity object, the method is stored in
  # method or in Metric, but we use metric in our own version to avoid a clash
  # with the method item in cluster()/hclust() further on (hclust change it
  # into dist.method, but it is better to have the right name right now)
  attr(dst, "metric") <- method
  # dist or dissimilarity object use Labels, but we use labels everywhere else
  # including in cluster()/hclust()
  # So, we make sure labels is present (in hclust, it is labels anyway!)
  attr(dst, "labels") <- rownames(data)
  # Default values for Diag and Upper set to FALSE
  if (is.null(attr(dst, "Diag"))) attr(dst, "Diag") <- FALSE
  if (is.null(attr(dst, "Upper"))) attr(dst, "Upper") <- FALSE
  # Keep info about how raw data were transformed
  attr(dst, "rownames.col") <- rownames.col
  attr(dst, "transpose") <- transpose
  attr(dst, "scale") <- scale
  class(dst) <- unique(c("dissimilarity", class(dst)))
  dst
}

as.dissimilarity <- function(x, ...)
  UseMethod("as.dissimilarity")
as_dissimilarity <- as.dissimilarity # Synonym

as.dissimilarity.matrix <- function(x, ...) {
  dst <- as.dist(x, ...)
  attr(dst, "call") <- match.call()
  attr(dst, "metric") <- attr(dst, "method") # Make sur metric is used
  class(dst) <- unique(c("dissimilarity", class(dst)))
  dst
}

# We want to print only the first few rows and columns
print.dissimilarity <- function(x, digits.d = 3L, rownames.lab = "labels",
  ...) {
  mat <- as.matrix(x)
  mat <- format(round(mat, digits.d))
  diag(mat) <- ""
  mat[upper.tri(mat)] <- ""
  class(mat) <- c("dst", "matrix")
  tbl <- tibble::as_tibble(mat)
  #tbl <- tibble::add_column(tbl, {{rownames.lab}} = rownames(mat), .before = 1)
  # I prefer this
  tbl <- dplyr::bind_cols(
    as_tibble_col(rownames(mat), column_name = rownames.lab), tbl)
  tbl <- tbl[, -ncol(tbl)]
  more_info <- ""
  if (isTRUE(attr(x, "scale"))) {
    if (isTRUE(attr(x, "transpose"))) {
      more_info <- " (transposed then scaled data)"
    } else {# Only scaled
      more_info <- " (scaled data)"
    }
  } else {
    if (isTRUE(attr(x, "transpose")))
      more_info <- " (transposed data)"
  }
  cat("Dissimilarity matrix with metric: ", attr(x, "metric"),
    more_info, "\n", sep = "")
  print(tbl)
  invisible(x)
}

labels.dissimilarity <- function(object, ...) {
  labs <- object$labels
  if (is.null(labs)) object$Labels
}

nobs.dissimilarity <- function(object, ...)
  attr(object, "Size")

# TODO: `[` by first transforming into a matrix with as.matrix()

autoplot.dissimilarity <- function(object, order = TRUE, show.labels = TRUE,
  lab.size = NULL, gradient = list(low = "red", mid = "white", high = "blue"),
  ...) {
  factoextra::fviz_dist(object, order = order, show_labels = show.labels,
    lab_size = lab.size, gradient = gradient)
}

chart.dissimilarity <- function(data, ...,
  type = NULL, env = parent.frame())
  autoplot(data, type = type, ...)

# A hack to get fun$type() working in learnr
#mds <- list(
#  metric = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "metric", ...),
#  nonmetric = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "nonmetric", ...),
#  cmdscale = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "cmdscale", ...),
#  wcmdscale = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "wcmdscale", ...),
#  sammon = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "sammon", ...),
#  isoMDS = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "isoMDS", ...),
#  monoMDS = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "monoMDS", ...),
#  metaMDS = function(dist, k = 2, p = 2, ...) mds(dist, k = k, p = p, type = "metaMDS", ...)
#)

# Chargement du jeu de donnÃ©es
bci <- read("BCI", package = "vegan")
```

```{r, echo=FALSE}
BioDataScience2::learnr_banner()
```

```{r, context="server"}
BioDataScience2::learnr_server(input, output, session)
```

------------------------------------------------------------------------

## Objectifs

Ce tutoriel consacrÃ© au positionnement multidimensionnel (MDS) vise Ã Â :

-   VÃ©rifier que vous avez bien compris les diffÃ©rentes Ã©tapes pour la rÃ©alisation d'une MDSÂ : calcul de la matrice de distance, calcul du positionnement des points, rÃ©alisation de la carte et vÃ©rification de sa validitÃ©, choix entre MDS mÃ©trique ou non mÃ©trique.
-   Vous prÃ©parer Ã  analyser et interprÃ©ter de maniÃ¨re autonome un jeu de donnÃ©es multivariÃ©es Ã  l'aide des MDS.

Vous devez avoir compris le contenu du [module 6](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/k-moyenne-mds-som.html) du cours et en particulier la [section 6.2](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/positionnement-multidimensionnel-mds.html). Assurez-vous d'avoir rÃ©alisÃ© les exercices H5P qui s'y trouvent avant de vous lancer dans ce tutoriel Learnr et de bien maÃ®triser les notions sur les matrices de distances vue dans le [module 5](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/distance-entre-individus.html).

## Barro Colorado Island

Barro Colorado est une Ã®le artificielle situÃ©e sur le lac GatÃ¹n, au centre du Panama. Elle reprÃ©sente un lieu de recherche scientifique intensive axÃ©e sur l'Ã©cologie de la forÃªt tropicale.

![Ile de Barro Colorado](images/bci_carte.png)

Une surface permanente de 50 hectares a Ã©tÃ© dÃ©finie par l'Institut de recherche tropicale Smithsonian et l'UniversitÃ© de Princeton pour Ã©tudier la dynamique de la vÃ©gÃ©tation. Cette surface est divisÃ©e en 50 parcelles de 1 ha, qui s'alignent les unes sur les autres. Dans chaque parcelle, le dÃ©nombrement de toutes les espÃ¨ces forestiÃ¨res a Ã©tÃ© enregistrÃ© (seules les plantes avec un DHP \>= 10 cm [DiamÃ¨tre mesurÃ© Ã  plus ou moins 1,3m] sont disponibles dans cet ensemble de donnÃ©es). Au total, 225 espÃ¨ces diffÃ©rentes ont Ã©tÃ© observÃ©es.

![Foret tropicale de l'ile de Barro Colorado](images/bci_forest.jpg)

Les donnÃ©es peuvent Ãªtre chargÃ©es Ã  partir de `"BCI"` dans le package {vegan} et se prÃ©sentent comme ceciÂ :

```{r, echo=TRUE}
bci <- read("BCI", package = "vegan")
bci
```

Toutes les variables du tableau reprÃ©sentent des espÃ¨ces (il n'y a pas ici une variable qui spÃ©cifie la station, par exemple). Elles sont donc toutes utilisables pour notre analyse.

<!-- TODO: il manque une partie description des donnÃ©es et Ã©ventuellement une transformation, cf espÃ¨ces rares, mais le graphique boxplot parallÃ¨le est inutilisable avec 225 espÃ¨ces!!! -->

### Matrice de distance

Lors de la rÃ©alisation d'une MDS, la premiÃ¨re Ã©tape nÃ©cessite de construire une matrice de distances entre les stations ou entre les espÃ¨ces comme vous l'aviez fait lors de la CAH. Pour cela, nous utiliserons la fonction `dissimilarity()` que vous connaissez dÃ©jÃ . Rappelez-vous que vous devrez commencer par sÃ©lectionner une mÃ©trique adaptÃ©e Ã  votre jeu de donnÃ©es pour calculer votre matrice. Pour rappel, vous explorez l'aide en ligne de `?vegan::vegdist` pour dÃ©terminer les arguments Ã  utiliser dans `dissimilarity()`.

A partir du jeu de donnÃ©es `bci`, calculez la matrice de distances entre stations en utilisant l'indice de Bray-Curtis sans transformation des donnÃ©es afin de privilÃ©gier les espÃ¨ces les plus abondantes dans votre analyse (choix au dÃ©part).

```{r dist_h2, exercise=TRUE}
bci_dist <- ___(___, ___)
```

```{r dist_h2-hint-1}
bci_dist <- ___(___, method = "___")

#### ATTENTION: Hint suivant = solution !####
```

```{r dist_h2-solution}
## Solution ##
bci_dist <- dissimilarity(bci, method = "bray")
```

```{r dist_h2-check}
grade_code("Vous n'avez pas oubliÃ© comment on fait pour calculer une matrice de distances avec la fonction `dissimilatity()`. C'est maintenant que cela devient intÃ©ressant...")
```

## MDS mÃ©trique (ou PCoA)

Lorsque votre matrice de distance `bci_dist` est calculÃ©e, vous allez pouvoir visualiser son contenu en rÃ©alisant une MDS mÃ©trique ou analyse en coordonnÃ©es principales (PCoA). L'objectif est de *"projeter"* le nuage de points initial Ã  *p* dimensions (les *p* variables) dans un espace rÃ©duit Ã  deux dimensions. Afin de calculer votre MDS mÃ©trique vous utilisez la fonction `mds$metric()` et `chart()` permet de visualiser votre ordination en deux dimensions (nommez simplement vos stations de 1 Ã  50 dans l'ordre d'apparition dans le tableau).

```{r metric_prep}
bci_dist <- dissimilarity(bci, method = "bray")
```

```{r metric_h2, exercise=TRUE, exercise.setup="metric_prep"}
bci_mds <- ___(___)
___(___, labels = 1:50)
```

```{r metric_h2-hint-1}
bci_mds <- ___$___(bci_dist)
___(bci_mds, labels = 1:50)

#### ATTENTION: Hint suivant = solution !####
```

```{r metric_h2-solution}
## Solution ##
bci_mds <- mds$metric(bci_dist)
chart(bci_mds, labels = 1:50)
```

```{r metric_h2-check}
grade_code("Vous venez de rÃ©aliser votre premiÃ¨re MDS mÃ©trique. Sur ce graphique, les stations qui sont proches les unes des autres ont un indice de dissimilaritÃ© faible et se ressemblent du point de vue de la composition en vÃ©gÃ©taux. Notez bien que ni lâorientation des axes, ni les valeurs absolues sur ces axes nâont de significations particuliÃ¨res. Sur ce graphique, vous pouvez voir qu'un petit groupe d'une douzaine de parcelles se dÃ©tache Ã  gauche du graphique. Un autre groupe s'individualise dans le bas... mais avant d'interprÃ©ter, nous devons vÃ©rifier le GOF pour dÃ©terminer si la reprÃ©sentation reste suffisamment fidÃ¨le Ã  la rÃ©alitÃ©.") 
```

### "Goodness-of-fit"

VÃ©rifiez toujours les indicateurs de "Goodness-of-fit" (GOF avec `glance()`) qui vous donneront une idÃ©e de la qualitÃ© de la projection MDS.

```{r gof_prep}
bci_dist <- dissimilarity(bci, method = "bray")
bci_mds <- mds$metric(bci_dist)
```

```{r gof_h2, exercise=TRUE, exercise.setup="gof_prep"}
___(___)
```

```{r gof_h2-hint-1}
___(bci_mds)

#### ATTENTION: Hint suivant = solution !####
```

```{r gof_h2-solution}
## Solution ##
glance(bci_mds)
```

```{r gof_h2-check}
grade_code("Tentez maintenant de rÃ©pondre Ã  la question qui vous est proposÃ©e ci-dessous.") 
```

```{r qu_mds}
question("ConsidÃ©rez vous que cette PCoA est une bonne PCoA ?",
  answer("oui, sur base du goodness-of-fit, la PCoA est fidÃ¨le aux distances"),
  answer("non, le goodness-of-fit est trop faible, nous devons tenter une MDS non mÃ©trique", 
  correct = TRUE),
  allow_retry = TRUE,
  correct = "Ces valeurs sont trop faibles. L'indicateur GOF1 donne une mesure de la part de variance du jeu de donnÃ©es initial qui a pu Ãªtre reprÃ©sentÃ©e. L'indicateur GOF2 quant Ã  lui correspond Ã  la somme des valeurs propres positives uniquement. Dans notre cas, les valeurs de GOF ne sont pas trÃ¨s Ã©levÃ©es, nous devons donc considÃ©rer que la carte n'est pas trÃ¨s reprÃ©sentative.",
  incorrect = "Corrigez votre rÃ©ponse. Plus la valeur se rapproche de 1, mieux ce sera. Des valeurs infÃ©rieures Ã  0.7 sont dÃ©jÃ  limites.")
```

## MDS non mÃ©trique

Tout comme la MDS mÃ©trique, la MDS non mÃ©trique, obtenue grÃ¢ce Ã  `mds$nonmetric()`, utilise une matrice de distances pour rÃ©aliser une carte mais en autorisant des Ã©carts entre les individus plus flexibles. On pourra donc forcer la carte Ã  Ãªtre littÃ©ralement Ã©crasÃ©e, tant que l'ordre des points est gardÃ© intact dans la distorsion (une dissimilaritÃ© plus grande ne peut pas Ãªtre reprÃ©sentÃ©e par une distance plus petite sur la carte). Cette distorsion est appelÃ©e un stress.

Le calcul rÃ©alisÃ© est itÃ©ratif, et comme il n'est pas garanti de converger, vous vÃ©rifierez qu'une solution Ã  bien Ã©tÃ© trouvÃ©e (indication `*** Solution reached` Ã  la fin). Pour les dÃ©tails et les paramÃ¨tres de cet algorithme, rÃ©fÃ©rez-vous Ã  l'aide en ligne de la fonction `?vegan::metaMDS`.

Vous avez toujours Ã  disposition la matrice de distance `bci_dist` sur laquelle vous allez rÃ©aliser votre MDS non mÃ©trique. Utilisez ensuite `chart()` pour rÃ©aliser la carte permettant de visualiser les distances entre les stations (que vous numÃ©rotez de 1 Ã  50 dans l'ordre d'apparition).

```{r nonmetric_prep}
bci_dist <- dissimilarity(bci, method = "bray")
```

```{r nonmetric_h2, exercise=TRUE, exercise.setup="nonmetric_prep"}
bci_nmds <- ___(___)
___(___, labels = 1:50)
```

```{r nonmetric_h2-hint-1}
bci_nmds <- ___$___(bci_dist)
___(bci_nmds, labels = 1:50)

#### ATTENTION: Hint suivant = solution !####
```

```{r nonmetric_h2-solution}
## Solution ##
bci_nmds <- mds$nonmetric(bci_dist)
chart(bci_nmds, labels = 1:50)
```

```{r nonmetric_h2-check}
grade_code("La reprÃ©sentation que nous obtenons est assez diffÃ©rente de celle de la MDS mÃ©trique. On retrouve deux groupes plus ou moins sÃ©parÃ©s Ã  gauche et au centre du graphique et puis deux stations isolÃ©es vers la droite et le haut du graphique.") 
```

### QualitÃ© de l'ajustement

La MDS non mÃ©trique est assortie d'indicateurs permettant d'Ã©valuer d'une part la qualitÃ© de l'ajustement et d'autre part la fonction de stress appliquÃ©e. Comme pour la PCoA, vous pouvez utiliser la fonction `glance()` pour obtenir une mesure de l'ajustement global de la MDS.

Analyser les indicateurs de l'objet `bci_nmds` que vous venez de crÃ©er et rÃ©pondez Ã  la question ci-dessous.

```{r ajust_prep}
bci_dist <- dissimilarity(bci, method = "bray")
bci_nmds <- mds$nonmetric(bci_dist)
```

```{r ajust_h2, exercise=TRUE, exercise.setup="ajust_prep"}
___(___)
```

```{r ajust_h2-hint-1}
___(bci_nmds)

#### ATTENTION: Hint suivant = solution !####
```

```{r ajust_h2-solution}
## Solution ##
glance(bci_nmds)
```

```{r ajust_h2-check}
grade_code("Bon, on commence Ã  s'habituer Ã  l'usage simple de `glance()`. Analysez maintenant ces mesures et rÃ©pondez Ã  la question ci-dessous.") 
```

```{r qu_nmds}
question("ConsidÃ©rez vous que cette MDS non mÃ©trique est de qualitÃ© ?",
  answer("Oui, car le R^2 non mÃ©trique est plus Ã©levÃ© que le R^2 linÃ©aire."),
  answer("Oui, les R^2 sont excellents, mÃªme si la linearitÃ© de la transformation est un peu en dessous.", correct = TRUE),
  answer("Non, le R^2 nion mÃ©trique est excellent, mais le R^2 linÃ©aire un cran en dessous rÃ©vÃ¨le un problÃ¨me."),
  answer("Non, il y a trop de diffÃ©rences entre les deux R^2."),
  allow_retry = TRUE,
  correct = "Dans la MDS non mÃ©trique, c'est le R^2 non mÃ©trique qui importe le plus. Un R^2 linÃ©aire trÃ¨s Ã©levÃ© est un plus, mais n'est pas indispensable. D'ailleurs s'il est Ã©galement trÃ¨s Ã©levÃ©, une MDS mÃ©trique pourrait convenir Ã©galement et est plus rapide Ã  calculer.",
  incorrect = "Pas tout Ã  fait. Plus la valeur du R^2 se rapproche de 1, mieux c'est, mais les deux R^2 n'ont pas la mÃªme importance ici.")
```

### Diagramme de Shepard

Le diagramme de Shepard (fonction `shepard()` pour le calculer puis `chart()` pour l'afficher) visualise la distorsion introduite par notre MDS non mÃ©trique. Une diffÃ©rence importante entre le R^2^ linÃ©aire et le R^2^ non linÃ©aire est une premiÃ¨re indication d'un stress important. La fonction `shepard()` demande d'une part la matrice de distance de dÃ©part et d'autre part, l'objet nmds pour pouvoir rÃ©aliser le calcul.

Sur le diagramme des dissimilaritÃ©s de la matrice *versus* distances sur la carte, le trait rouge matÃ©rialise la fonction de stress. Plus les points sont proches de ce trait, mieux c'est en mode non linÃ©aire. De plus, si ce trait se rapproche d'une droite, alors la linÃ©aritÃ© est d'autant mieux respectÃ©e Ã©galement. C'est donc une analyse en deux Ã©tapes que l'on fait ici par observation du diagrammeÂ : d'abord, une fidÃ©litÃ© pour des distances similaires, ert en second lieu comme bonus Ã©ventuellement, un respect des distances relatives les unes par rapport aux autres.

RÃ©aliser le diagramme de Shepard pour votre MDS non mÃ©trique.

```{r shepard_prep}
bci_dist <- dissimilarity(bci, method = "bray")
bci_nmds <- mds$nonmetric(bci_dist)
```

```{r shepard_h2, exercise=TRUE, exercise.setup="shepard_prep"}
bci_sh <- ___(___, ___)
___(___)
```

```{r shepard_h2-hint-1}
bci_sh <- ___(bci_dist, ___)
___(bci_sh)

#### ATTENTION: Hint suivant = solution !####
```

```{r shepard_h2-solution}
## Solution ##
bci_sh <- shepard(bci_dist, bci_nmds)
chart(bci_sh)
```

```{r shepard_h2-check}
grade_code("Comme vous le voyez, les points sont relativement proches de la fonction de stress. Et plus ils seront proches, mieux ce sera. Par contre la forme de la fonction de stress n'est pas trÃ¨s linaire. Nous pouvions nous y attendre, car si cela avait Ã©tÃ© le cas, la MDS mÃ©trique aurait aussi bien fonctionnÃ© sur ces donnÃ©es.") 
```

## Conclusion

FÃ©licitationÂ ! Vous venez de terminer votre auto-Ã©valuation relative au positionnement multidimensionnel. Vous maÃ®trisez maintenant les notions et fonctions de base nÃ©cessaires pour la rÃ©alisation ce type d'analyse et vous pouvez vous lancer dans le projet relatif Ã  cette matiÃ¨re.

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur cet outil pÃ©dagogique",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrÃ©s.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
