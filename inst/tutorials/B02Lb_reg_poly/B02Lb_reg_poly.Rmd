---
title: "Régression linéaire polynomiale"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD II Module 2** Maîtriser la régression linéaire polynomiale."
tutorial:
  id: "B02Lb_reg_poly"
  version: 2.1.0/7
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience2::learnr_setup()
SciViews::R("model", lang = "fr")

diabetes <- read("diabetes", package = "faraway")
diabetes <- janitor::clean_names(diabetes)
diabetes <- smutate(diabetes, 
  map  = bp_1d + 1/3 * (bp_1s - bp_1d),
  age2 = age^2)
is.labelled <- function(x) inherits(x, c("labelled", "haven_labelled"))
diabetes <- smutate(diabetes, across(sapply(diabetes, is.labelled), .fns = as.numeric))
diabetes <- labelise(diabetes, 
  label = list(map = "Tension artérielle moyenne", age = "Âge"), 
  units = list(map = "mm Hg", age = "années")
)

map_lm1 <- lm(data = diabetes, map ~ age)

map_lm2 <- lm(data = diabetes, map ~ age + I(age^2))
lm_poly_coef <- tidy(map_lm2)
lm_poly_param <- glance(map_lm2)
```

```{r, echo=FALSE}
BioDataScience2::learnr_banner()
```

```{r, context="server"}
BioDataScience2::learnr_server(input, output, session)
```

------------------------------------------------------------------------

## Objectifs

-   Maîtriser la régression linéaire polynomiale dans R avec la fonction `lm()`.
-   Utiliser le critère d'Akaike pour comparer deux modèles.

## Description des données

Un cycle cardiaque se décompose en deux parties. La contraction cardiaque est la systole et la relaxation cardiaque est la diastole. On peut mesurer la pression de chaque phase à l'aide d'un tensiomètre en millimètre de mercure. La valeur de référence est de 140/90 mm Hg. La valeur de 140 représente la pression systolique (**SP**) et la valeur de 90 la pression diastolique (**DP**). Une tension comprise entre 100/70 et 140/90 mmHg va être considérée comme normale.

![Mesure de la pression artérielle, photo de [Pavel Danilyuk, Pexels](https://www.pexels.com/photo/a-healthcare-worker-measuring-a-patient-s-blood-pressure-using-a-sphygmomanometer-7108344/).](images/blood_pressure.jpg)

La pression artérielle moyenne (**MAP**) se détermine ensuite d'après la formule suivante :

$$MAP = DP + 1/3*(SP-DP)$$

La tension artérielle moyenne optimale va être comprise entre 80 et 107. Les études ont montré que la pression artérielle augmente avec l'âge. Cette augmentation s'explique entre autres par la perte d'élasticité des artères.

Le but de ce tutoriel est de modéliser la variation de la pression artérielle moyenne en fonction de l'âge. Vous avez le jeu de données suivant à votre disposition.

```{r, echo = TRUE, warning=FALSE}
SciViews::R("model", lang = "fr") # System configuration

# Import dataset
diabetes <- read("diabetes", package = "faraway")
# Rework the dataset
diabetes <- janitor::clean_names(diabetes)
skimr::skim(diabetes)
# Correct label in French for age
diabetes$age <- labelise(diabetes$age, "Âge", units = "années")
# Some columns are of class "labelled", we convert them into numeric
is.labelled <- function(x) inherits(x, c("labelled", "haven_labelled"))
diabetes <- smutate(diabetes, across(sapply(diabetes, is.labelled), .fns = as.numeric))
```

> La dernière instruction mérite une petite explication. Nous avons plus d'une dizaine de variables dans le jeu de données qui ont la classe "labelled". Ce sont toutes des données quantitatives numériques et nous les voulons comme telles. Les transformer une à une explicitement serait fastidieux. Alors, nous avons fait appel ici à la fonction `across()` qui applique une transformation via son argument `.fns=` (ici, `as.numeric`) sur toutes les colonnes dont le nom est donné par le premier argument, ou via un vecteur de valeurs logiques de même taille que le nombre de variables du tableau. Comme nous voulons transformer toutes les colonnes qui héritent de la classe "labelled", nous appliquons le test sur toutes les colonnes (la fonction `sapply()` s'en charge) à l'aide de `is.labelled` définie juste au dessus qui fait ce test. Cela équivaut à utiliser `is.labelled(X)` avec `X` qui vaut tour à tour chacune des variables du tableau. Avec la function tidy `mutate()`, on aurait aussi pu écrire `across(where(is.labelled), .fns = as.numeric)`, mais `where()` n'est pas (encore) disponible pour les fonctions speedy comme `smutate()`.

Les données ont été collectées au sein d'une population afro-américaine dans l'état de Virginie aux USA dans le but d'étudier la prévalence du diabète, de l'obésité, et d'autres facteurs de risques cardio-vasculaires. Dans le cadre de cet exercice, nous allons nous limiter à quelques variables. Les pressions systoliques et diastoliques ont été mesurées deux fois : `bp.1s` pour la première systolique, `bp.1d` pour la première diastolique, et `bp.2s`, `bp.2d` pour la seconde série de mesures. Vous n'utiliserez que la première série. L'âge est exprimé en années dans la variable `age`.

## Pression artérielle moyenne

Débutez votre étude par calculer la variable `map` à partir de `bp.1s` et `bp.1d` du tableau `diabetes`. Pour rappel, la formule est :

$$MAP = DP + 1/3*(SP-DP)$$

Réalisez ensuite dans la foulée un graphique ne nuage de points de la pression artérielle moyenne en fonction de l'âge.

```{r chart_h2, exercise=TRUE}
diabetes <- smutate(diabetes,
  map = ___ |> labelise("Tension artérielle moyenne", units = "___"))

chart(data = ___, ___ ~ ___) +
  geom____(na.rm = TRUE)
```

```{r chart_h2-hint-1}
diabetes <- smutate(diabetes,
  map = bp_1d + ___ * (___ - ___) |> labelise("Tension artérielle moyenne", units = "mm Hg"))

chart(data = ___, ___ ~ ___) +
  geom_point(na.rm = TRUE)

#### ATTENTION: Hint suivant = solution !####
```

```{r chart_h2-solution}
## Solution ##
diabetes <- smutate(diabetes,
  map = bp_1d + 1/3 * (bp_1s - bp_1d) |> labelise("Tension artérielle moyenne", units = "mm Hg"))

chart(data = diabetes, map ~ age) +
  geom_point(na.rm = TRUE)
```

```{r chart_h2-check}
grade_code("Vous venez de calculer MAP et de représenter graphiquement MAP en fonction de l'âge. Que voyez-vous d'intéressant sur ce graphique ?")
```

## Modélisation

Réalisez tout d'abord la régression linéaire de la pression artérielle moyenne (`map`) en fonction de l'âge (`age`). Le seuil alpha fixé dans le cadre de cette recherche est de 10%.

```{r reglin_h2, exercise = TRUE}
map_lm1 <- lm(data = ___, ___ ~ ___)
# Résumé du modèle
summary(___)
# Graphique du modèle
chart(___)
```

```{r reglin_h2-hint-1}
map_lm1 <- lm(data = ___, ___ ~ ___)
# Résumé du modèle
summary(map_lm1)
# Graphique du modèle
chart(map_lm1)

#### ATTENTION: Hint suivant = solution !####
```

```{r reglin_h2-solution}
## Solution ##
map_lm1 <- lm(data = diabetes, map ~ age)
# Résumé du modèle
summary(map_lm1)
# Graphique du modèle
chart(map_lm1)
```

```{r reglin_h2-check}
grade_code("Bon, voilà notre régression linéaire. Le R^2 faible de 0.07 nous indique une forte variabilité autour de la droite. Nous le voyons effectivement sur le graphique.")
```

Réalisez ensuite une **régression linéaire polynomiale d'ordre 2** avec les mêmes variables.

```{r regpoly_h2, exercise=TRUE}
map_lm2 <- lm(data = ___, ___ ~ ___ + ___(___))
# Résumé du modèle
summary(___)
# Graphique du modèle
chart(___)
```

```{r regpoly_h2-hint-1}
map_lm2 <- lm(data = ___, ___ ~ ___ + I(___))
# résumé du modèle
summary(map_lm2)
# Graphique du modèle
chart(map_lm2)

#### ATTENTION: Hint suivant = solution !####
```

```{r regpoly_h2-solution}
## Solution ##
map_lm2 <- lm(data = diabetes, map ~ age + I(age^2))
# résumé du modèle
summary(map_lm2)
# Graphique du modèle
chart(map_lm2)
```

```{r regpoly_h2-check}
grade_code("Voici notre parabole ajustée dans les données... Est-ce mieux que la droite ?")
```

**N'oubliez pas de simplifier votre modèle, si nécessaire**

Analysez les résultats ci-dessus et répondez aux questions suivantes :

```{r qu_regpoly}
quiz(
  question(text = "Quelle est la valeur de l'ordonnée à l'origine pour la régression polynomiale d'ordre 2 ?",
    answer(sprintf("%.4f", lm_poly_coef$estimate[1]), correct = TRUE),
    answer(sprintf("%.4f", lm_poly_coef$estimate[2])),
    answer(sprintf("%.4f", lm_poly_coef$std.error[1])),
    answer(sprintf("%.4f", lm_poly_coef$std.error[2])),
    answer(sprintf("%.4f", lm_poly_coef$statistic[1])),
    answer(sprintf("%.4f", lm_poly_coef$statistic[2])),
    answer(sprintf("%.4f", lm_poly_param$r.squared[1])),
    allow_retry = TRUE, random_answer_order = TRUE
    ),
  question(text = "Quelle est la part de la variance exprimée par ce modèle ?",
    answer(sprintf("%.2f", lm_poly_coef$estimate[1])),
    answer(sprintf("%.2f", lm_poly_coef$estimate[2])),
    answer(sprintf("%.2f", lm_poly_coef$std.error[1])),
    answer(sprintf("%.2f", lm_poly_param$r.squared[1])),
    answer(sprintf("%.2f", lm_poly_coef$statistic[1])),
    answer(sprintf("%.2f", lm_poly_coef$statistic[2])),
    answer(sprintf("%.2f", lm_poly_param$adj.r.squared[1]), correct = TRUE),
    allow_retry = TRUE, random_answer_order = TRUE
    )
)
```

Voici l'analyse des résidus de la régression linéaire. Prenez le temps d'interpréter ces graphiques.

```{r}
chart$residuals(map_lm1)
```

Et voici l'analyse des résidus de la régression polynomiale d'ordre 2.

```{r}
chart$residuals(map_lm2)
```

## Choix du meilleur modèle

Il n'est pas facile de choisir le meilleur modèle dans le cas présent sur base d'une inspection visuelle, y compris via l'analyse des résidus. Calculez le critère d'Akaike pour chaque modèle afin de vous aider dans le choix du meilleur.

```{r aic, exercise=TRUE}
___(___, ___)
```

```{r aic-solution}
## Solution ##
AIC(map_lm1, map_lm2)
```

```{r aic-check}
grade_code("Voilà les valeurs des deux criètres d'Akaike. Qule modèle est le meilleur d'après cette métrique ?")
```

Suite à votre analyse, répondez aux questions suivantes :

```{r qu_aic}
question(text = "Quel est le meilleur modèle selon le critère d'Akaike",
  answer("modèle polynomial d'ordre 2", correct = TRUE),
  answer("modèle linéaire simple"),
  allow_retry = TRUE,
  incorrect = "C'est la valeur la plus faible qui indique le meilleur modèle selon le critère d'Akaike",
  correct = "Le meilleur modèle est celui qui a la valeur la plus faible selon le critère d'Akaike.",
  submit_button = "Soumettre une réponse", 
  try_again_button = "Resoumettre une réponse")
```

*Le critère d'Akaike est une métrique qui aide à déterminer quel est le meilleur modèle. N'utilisez jamais le R^2^ pour cela, car si vous comparer un modèle simple et un modèle plus complexe (avec plus de paramètres), il est à peu près certain que le modèle plus complexe et plus flexible s'ajustera mieux dans les données et donnera un meilleur R^2^, mais il peut s'agir ici de **surajustement** qui n'exprime pas une meilleure qualité de ce modèle complexe.*

## Conclusion

Vous venez de terminer ce tutoriel sur la régression polynomiale. Le jeu de données utilisé montre une grande dispersion des valeurs et une faible corrélation entre les variables `map` et `age`. Cependant, les modèles sont quand même significatifs (l'ANOVA de la régression, autant que les tests *t* de Student sur les paramètres l'indiquent dans les deux cas, au seuil alpha choisi de 10%). Le choix entre les deux modèles n'est pas aisé visuellement ici. Nous avons utilisé le critère d'Akaike pour nous aider à prendre une décision.

Que faire ensuite ? Si l'âge a un effet sur la tension artérielle, il est évident que ce n'est pas le seul facteur. Notre modèle doit être complété en y incluant d'autres variables du jeu de données `diabetes` (régression multiple et polynomiale). Vous pouvez tester par vous-mêmes l'ajout de ces autres variables pour diminuer les résdus du modèle, mais l'exercice concernant la régression polynomiale est maintenant terminé.

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur ce learnr",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE,
  submit_button = "Soumettre une réponse", 
  try_again_button = "Resoumettre une réponse"
)
```
