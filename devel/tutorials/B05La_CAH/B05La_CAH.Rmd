---
title: "Classification hiérarchique"
author: "Guyliann Engels, Raphael Conotte & Philippe Grosjean"
description: "**SDD II Module 5** Application des concepts à la classification hiérarchique."
tutorial:
  id: "B05La_CAH"
  version: 2.0.0/10
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience2::learnr_setup()
SciViews::R()
library(ade4)
data("doubs")
enviro <- doubs$env
fish <- doubs$fish
```

```{r, echo=FALSE}
BioDataScience2::learnr_banner()
```

```{r, context="server"}
BioDataScience2::learnr_server(input, output, session)
```

----

## Objectifs

- Comprendre la notion de distance et la matrice de distances.

- Savoir calculer des matrices de distances avec la fonction `vegdist()`

- Appréhender la classification hiérarchique et le dendrogramme.

- Maîtriser l'utilisation de la fonction `hclust`. 

- Être capable d’effectuer un regroupement pertinent des individus d’un jeu de données multivarié à l’aide de ces techniques.

Vous devez avoir étudié le contenu du [module 5](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/hierarchique.html) du cours.

## Abondance d'espèces de poissons

Des scientifiques ont réalisé des mesures d'abondance d'espèces de poissons et des mesures physico-chimiques sur 30 stations différentes.

L'objet `doubs` du package `ade4` est une liste qui contient 4 jeux de donnnées. Dans un premier temps, vous allez vous intéresser aux données sur l'abondance de 27 espèces de poissons sur les 30 sites. Ces données, présentent dans l'objet `fish`, sont présentées ci-dessous. 

```{r}
head(fish)
```

### Choix de l'indice

```{r qu_indice1}
question("À partir des données du tableau présenté ci-dessus, vous souhaitez réaliser un matrice de distance avec l'indice le plus adapté. Quel indice choississez vous ? (plusieurs réponses peuvent être sélectionnés)",
          answer("Indice de Bray-Curtis", correct = TRUE),
          answer("Indice de Canberra", correct = TRUE),
          answer("Distance Euclidienne"),
          answer("Indice de Manhattan"), 
          allow_retry = TRUE, random_answer_order = TRUE)
```

### Indice de Bray-Curtis

A partir des données contenues dans `fish`, calculez la matrice de distances en utilisant l'indice de Bray_Curtis utilisé par défaut dans la fonction `vegdist()`.

```{r bray_h2, exercise = TRUE}
fish_dist <- <- ___(___) 
# Afficher la matrice de distances arrondie à 2 décimales 
___(___, ___)
```

```{r bray_h2-hint-1}
enviro_dist <- vegan::vegdist(DF)
# Afficher la matrice de distances arrondie à 2 décimales 
round(OBJECT_DIST, ___)

#### ATTENTION: Hint suivant = solution !####
```

```{r bray_h2-solution}
fish_dist <- vegan::vegdist(fish)
# Afficher la matrice de distances arrondie à 2 décimales 
round(fish_dist, 2)
```

```{r bray_h2-check}
grade_code("Bravo ! Vous venez de réaliser votre première matrice de distances. Savez-vous qu'il existe d'autres indices ? Vous pouvez facilement changer de methode de calcul en utilisant l'argument `method =` de la fonction `vegdist()` en précisant entre guillements l'indice que vous souhaitez utiliser ("canberra" pour l'indice de Canberra, "euclidean" pour la distance Euclidienne et "manhattan" pour la distance de Manhattan.)")
```

### Indice de Canberra

A partir des données contenues dans `fish`, calculez la matrice de distances en utilisant l'indice de Canberra pour l'argument `method =` dans la fonction `vegdist()`.

```{r canberra_h2, exercise = TRUE}
fish_dist <- <- ___(___, ___) 
# Afficher la matrice de distances arrondie à 2 décimales 
___(___, ___)
```

```{r canberra_h2-hint-1}
enviro_dist <- vegan::vegdist(DF, method = ___)
# Afficher la matrice de distances arrondie à 2 décimales 
round(OBJECT_DIST, ___)

#### ATTENTION: Hint suivant = solution !####
```

```{r canberra_h2-solution}
fish_dist <- vegan::vegdist(fish, method = "canberra")
# Afficher la matrice de distances arrondie à 2 décimales 
round(fish_dist, 2)
```

```{r canberra_h2-check}
grade_code("Facile non ! Notez aussi que les matrices de distances ne sont pas prévues pour être imprimées et visualisées telles quelles. Ils constituent la première étape vers une représentation utile à l’aide de la classification hiérarchisée. Réprésentation qui sera abordée un peu plus loin dans ce learnr !")
```

## Données environnementales

En plus des données sur l'abondance de 27 espèces de poisson, l'objet `doubs` du package `ade4` contient également les données portant sur les mesures environnementales. Le tableau présenté ci-dessous comprend 30 sites d'échantillonages avec 11 mesures environnementales.

Voici une courte description des variables étudiées (en anglais). Ces informations proviennent de la page d'aide `?ade4::doubs`

- dfs : distance from the source (km * 10), 
- alt : altitude (m), 
- slo : (log(x + 1) where x is the slope (per mil * 100), 
- flo : minimum average stream flow (m3/s * 100), 
- pH : pH,
- har : total hardness of water (mg/l of Calcium), 
- pho : phosphates (mg/l * 100), 
- nit : nitrates (mg/l * 100), 
- amm : ammonia nitrogen (mg/l * 100), 
- oxy : dissolved oxygen (mg/l * 10), 
- bdo : biological demand for oxygen (mg/l * 10)

```{r}
head(enviro)
```

### Choix de l'indice

```{r qu_indice2}
question("Vous souhaitez réaliser un matrice de distances sur les données présentent dans ce tableau. Quels sont les indices le plus adapté.?",
          answer("Indice de Bray-Curtis"),
          answer("Indice de Canberra"),
          answer("Distance Euclidienne", correct = TRUE),
          answer("Indice de Manhattan", correct = TRUE), 
          allow_retry = TRUE, random_answer_order = TRUE)
```

### Distance Euclidienne 1

A partir des données contenues dans `enviro`, calculez la matrice de distances en utilisant la distance Euclidienne.

```{r euclidean1_h2, exercise = TRUE}
enviro_dist <- ___(___, ___) 
# Afficher la matrice de distances arrondies à 2 décimales 
___(___, ___)
```

```{r euclidean1_h2-hint-1}
enviro_dist <- vegan::vegdist(DF, method = ___)
# Afficher la matrice de distance arrondies à 2 décimales 
round(OBJECT_DIST, ___)

#### ATTENTION: Hint suivant = solution !####
```

```{r euclidean1_h2-solution}
enviro_dist <- vegan::vegdist(enviro, method = "euclidean")
# Afficher la matrice de distance arrondies à 2 décimales 
round(enviro_dist, 2)
```

```{r euclidean1_h2-check}
grade_code("Très bien ! Mais les unités respectives de vos variables n'ont pas été considérées. L'altidude en (m) ou la concentration en nitrates (mg/l * 100), par exemple, ne sont pas mesurées dans les mêmes unités. Le risque est alors de donner plus de poids aux valeurs élevées. Il est donc préférable de commencer par standardiser le tableau (moyenne de zéro et écart type de un) selon les colonnes avant d’effectuer le calcul. La fonction `scale()` permet de le faire et c'est ce que vous allez réaliser dans l'exercice suivant.")
```

### Distance Euclidienne 2

Calculez une nouvelle matrice de distances, mais cette fois après avoir standardisé les données avec la fonction `scale()`. Convertisser ensuite la matrice obtenue avec la fonction `as_tibble()` avant de procéder au calcul de la matrice de distances en utilisant la distance Euclidienne. 

```{r euclidean2_h2, exercise = TRUE}
___%>.%
  # Standardisation des 11 colonnes
  ___(___) %>.% 
  # Conversion de la matrice en data.frame + tibble
  ___(___) %>.%
  # Calcul de la matrice de distances
  ___(___, ___) -> enviro_dist
# Afficher la matrice de distance arrondies à 2 décimales 
___(___, ___)
```

```{r euclidean2_h2-hint-1}
DF %>.%
  # Standardisation des 11 colonnes
  scale(___) %>.% 
  # Conversion de la matrice en data.frame + tibble
  as_tibble(___) %>.%
  # Calcul de la matrice de distances
  vegan::___(___, method = ___) -> enviro_dist
# Afficher la matrice de distances arrondie à 2 décimales 
round(OBJECT_DIST, ___)

#### ATTENTION: Hint suivant = solution !####
```

```{r euclidean2_h2-solution}
enviro %>.%
  # Standardisation des 11 colonnes
  scale(.) %>.% 
  # Conversion de la matrice en data.frame + tibble
  as_tibble(.) %>.%
  # Calcul de la matrice de distances
  vegan::vegdist(., method = "euclidean") -> enviro_dist
# Afficher la matrice de distances arrondie à 2 décimales 
round(enviro_dist, 2)
```

```{r euclidean2_h2-check}
grade_code("Félicitiation, vous gérez vraiment bien les matrices de distances. Vous pourriez aussi essayer une autre méthode sur ces données standardisées comme la distance de Manhattan en utilisant `method = "manhattan"`.")
```

## Classification hiérarchique 

Maintenant que vous maitrisez le calcule des matrices de distances, vous pouvez obtenir facilement une matrice de distances entre toutes les paires de stations présentent dans le jeu de données `enviro`. Vous pouvez dès lors essayer de les regrouper en fonction de leur ressemblance. 
Vous allez maintenant apprendre à représenter graphiquement ces regroupements en utilisant un **dendrogramme**. 

```{r hac_prep}
enviro %>.%
  scale(.) %>.% 
  as_tibble(.) %>.%
  vegan::vegdist(., method = "euclidean") -> enviro_dist
```

### Dendrogramme 1

Commencez par calculer le dendgrogramme à l'aide de la fonction `hclust()` et de la matrice de distance `enviro_dist` que vous avez à disposition et qui correspond à la matrice calculée dans l'exercice précédant.

Utiliser ensuite la fonction `plot()` pour tracer le dendrogramme. 

```{r hclust1_h2, exercise = TRUE, exercise.setup = "hac_prep"}
enviro_clust <- ___(___)
___(___)
```

```{r hclust1_h2-hint-1}
enviro_clust <- hclust(___)
plot(___)

#### ATTENTION: Hint suivant = solution !####
```

```{r hclust1_h2-solution}
enviro_clust <- hclust(enviro_dist)
plot(enviro_clust)
```

```{r hclust1_h2-check}
grade_code("Félicitation ! Vous venez de réaliser votre premier dendrogramme. Savez-vous qu'il existe plusieurs stratégies possibles pour comparer les distances ? Utiliser l'argument `method =` de la fonction `hclust()` pour changer de méthode. Par défaut, c'est la méthode des liens complets qui est utilisée `method = "complete"`.")
```

### Dendrogramme 2

Réalisez un nouveau dendrogramme à partir de l'objet `enviro_dist` mais cette fois, utilisez la méthode de Ward `method = "ward.D2"` dans la fonction `hclust()`.

Utilisez la fonction `ggdendro::ggdendrogram()` pour visualiser le dendrogramme. 

```{r hclust2_h2, exercise = TRUE, exercise.setup = "hac_prep"}
enviro_clust <- ___(___, ___)
___(___)
```

```{r hclust2_h2-hint-1}
enviro_clust <- hclust(___, method = ___)
ggdendro::ggdendrogram(___)

#### ATTENTION: Hint suivant = solution !####
```

```{r hclust2_h2-solution}
enviro_clust <- hclust(enviro_dist, method = "ward.D2")
ggdendro::ggdendrogram(enviro_clust)
```

```{r hclust2_h2-check}
grade_code("Très bien ! Regardez comme cette technique vous a permis d'obtenir des groupess bien individualisés. Il existe bien d'autres méthodes que vous pouvez utilser pour calculer votre dendrogramme. Utiliser l'aide de la fonction `hclust()` pour voir comment les renseigner dans l'argument `method = `.")
```

### Dendrogramme 3

```{r group_prep}
enviro %>.%
  scale(.) %>.% 
  as_tibble(.) %>.%
  vegan::vegdist(., method = "euclidean") -> enviro_dist
enviro_clust <- hclust(enviro_dist, method = "ward.D2")
```

Réprésentez avec la fonction `plot()` le dendrogramme que vous venez de calculer dans l'exercice précédant. Matérialisez ensuite sur ce graphique une coupure en traçant un trait horizontal rouge avec la fonction `abline()` à une hauteur de 8. Vous avez à disposition l'objet `enviro_clust`. 

```{r hclust3_h2, exercise = TRUE, exercise.setup = "group_prep"}
___(___)
___(___,___)
```

```{r hclust3_h2-hint}
___(OBJET_CLUST)
abline(h = ___, col = ___)
```

```{r hclust3_h2-solution}
plot(enviro_clust)
abline(h = 8, col = "red")
```

```{r hclust3_h2-check}
grade_code("Bravo. Une coupure à ce niveau permet de former 4 groupes.")
```

### Dendrogramme 4 

Utilisez la fonction `cutree()` l'objet `enviro_clust`. Cela vous permettra d'obtenir pour chacunes des stations le numéros du groupe dans lequelle elle se trouve dans l'ordre de notre tableau de donnée. 

Ajoutez ces regroupements dans le tableau `enviro` en les transformant en facteur avec la fonction `as.factor()`.

Terminez en réalisant, un graphique en nuage de points de l'altidude (`alt`) en fonction de la distance de la source (`dfs`) en utilisant la variable groupe que vous venez de créer pour la couleur. 

```{r hclust4_h2, exercise = TRUE, exercise.setup = "group_prep"}
group <- ___(___, ___)
enviro$group <- ___(___)
chart(___, ___ ~ ___ ) +
  ___()
```

```{r hclust4_h2-hint-1}
group <- cutree(OBJET_CLUST, h = ___)
enviro$group <- as.factor(___)
chart(data = DF, VARNUM ~ VARNUM %col=% ___) +
  geom_point()
```

```{r hclust4_h2-solution}
group <- cutree(enviro_clust, h = 8)
enviro$group <- as.factor(group)
chart(data = enviro, alt ~ dfs %col=% group) +
  geom_point()
```

```{r hclust4_h2-check}
grade_code("Félicitation ! Vous venez de réaliser une étude complète en utilisant la **classification ascendante hiérarchique**. ")
```

## Conclusion

Bravo ! Vous venez de terminer votre auto-évaluation relative aux matrices de distances et à la classification hiérarchique. 

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur cet outil pédagogique",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
