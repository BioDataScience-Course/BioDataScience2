---
title: "K-moyennes"
author: "Guyliann Engels, Raphael Conotte & Philippe Grosjean"
description: "**SDD II Module 6** Regroupement par les K-moyennes"
tutorial:
  id: "B06La_kmeans"
  version: 2.0.0/4
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience2::learnr_setup()
SciViews::R()
library(BioDataScience)
library(ade4)

# Preparation dataset ------
SciViews::R()
library(ade4)

# Preparation dataset ------
data("doubs", package = "ade4")
enviro <- as_tibble(doubs$env)
```

```{r, echo=FALSE}
BioDataScience2::learnr_banner()
```

```{r, context="server"}
BioDataScience2::learnr_server(input, output, session)
```

----

## Objectifs

Les k-moyennes sont une méthode qui permet de réaliser des regroupements d'individus en partant d'un tableau multivarié. Cette méthode a le même objectif que la classification hiérarchique ascendante que vous avez découverte dans le module précédent. Cette méthode a l'avantage par rapport à la classification hiérarchique d'être moins gourmande en temps de calcul et en mémoire vive. Elle sera donc à privilégier lorsque vous vous retrouvez confronté à un grand jeu de données.

Dans ce learnr, vous allez pouvoir auto-évaluer votre capacité à\ :

- comprendre les différentes étapes de la classification par les k-moyennes : choix du nombre de groupes, classification par les k-moyennes, récupération des coordonnées des centres et représentation graphique.
- analyser et interpréter de manière autonome un jeu de données multivariées à l'aide des k-moyennes

N'entamer ce tutoriel qu'après avoir compris le principe des k-moyennes proposé dans le [module 6](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/k-moyenne-mds-som.html) du cours et en particulier la [section 6.1](https://wp.sciviews.org/sdd-umons2/?iframe=wp.sciviews.org/sdd-umons2-2020/k-moyennes.html). 

Assurez-vous d'avoir réalisé les exercices H5P qui s'y trouvent avant de vous lancer dans ce tutoriel learnr.

## Données environnementales du Doubs

Lors d'une étude visant à analyser l'abondance de 27 espèces de poissons sur 30 stations le long du Doubs, une rivière qui serpente entre la France et la Suisse pour se jeter finalement dans la Saône, les chercheurs y ont également mesuré des variables environnementales.

![Carte du Doubs, d'après OpenStreetMap.](images/doubs.jpg){width='60%'} 

Ces données environnementales peuvent notamment servir à classer les micro-habitats selon des critères différents. C'est ce que nous allons essayer de faire avec l'aide de la classification par les k-moyennes. Voici le détail des onze variables mesurées. Notez que les auteurs ont décidé d'appliquer des coefficients multiplicateurs ici pour homogénéiser les données : 

| label   | description                      | unités * coef |
|:-------:|:---------------------------------|:--------------|
| **dfs** | distance depuis la source        | km * 10       |
| **alt** | altitude                         | m             |
| **slo** | pente des berges en `log(x + 1)` | ‰ * 100       |
| **flo** | flux moyen minimum               | m^3^/s * 100  |
| **pH**  | pH de l'eau                      | - * 10        |
| **har** | dureté totale de l'eau           | mg Ca^++^/L   | 
| **pho** | phosphates                       | mg/L * 100    |
| **nit** | nitrates                         | mg/L * 100    |
| **amm** | azote ammoniacal                 | mg/L * 100    |
| **oxy** | oxygène dissout                  | mg/L * 10     |
| **bdo** | demande biologique en oxygène    | mg/L * 10     |

Voici les premières lignes du tableau `enviro` qui contient ces données.

```{r}
head(enviro)
```

### Choix du nombre de clusters

Le regroupement par les K-moyennes est une méthode simple d'analyse multivariée considérée comme moins efficace que le CAH. Néanmoins, cette méthode permet de réaliser des regroupements plus rapidement sur des gros jeu de données, là où la CAH nécessiterait trop de temps de calcul et de mémoire vive. 

L'un des inconvénients de cette méthode est que vous devez proposer le nombre de groupes *k* que vous souhaitez utiliser avant de pouvoir calculer vos regroupements grâce aux k-moyennes. Pour vous aider dans ce choix, le package `factoextra` propose avec la fonction `fviz_nbclust()`, un outil graphique permettant de donner une indication sur le nombre de groupes *k* optimal. 

Il existe plusieurs méthodes pour déterminer le nombre de groupes optimal. Nous vous proposons d'utiliser la méthode `wss` (total within sum of square). Cette méthode va de calculer la somme des carrés des distances intra-groupes en fonction du nombre de centres *k*. Plus le nombre de *k* va augmenter, plus la somme des carrés des distances intra-groupes va tendre à diminuer. On va devoir déterminer le nombre de groupes le plus approprié. L'objectif est de choisir le *k* le plus élevé qui permet d'avoir une forte diminution de la somme des carrés distances intra-groupes par rapport au *k* inférieur. Par contre lorsque l'ajout d'un groupe ne permet plus de diminuer fortement la valeur de *k*, c'est que nous avons trouvé la valeur de *k* optimal.

**Soyez toujours vigilant ! Le nombre de groupes proposé par factoextra::fviz_nbclust() n’est qu’indicatif !**

Sur base du jeu de données `enviro`, réalisez un graphique permettant d'estimer le nombre de groupes à employer dans la méthode des k-moyennes. Les variables mesurées ayant des unités différentes, n'oubliez pas de **standardiser** vos données en utilisant la fonction `scale()` et assigné les ensuite à `enviro_scale`. Ce n'est pas le cas pour ce jeu de données, mais pensez à éliminer les colonnes non numériques à l’aide de `select()` si vous en avez dans votre tableau de départ. 

```{r nbclust_h2, exercise=TRUE}
enviro_scale <- ___(___)
___::___(___, kmeans, method = "wss")
```

```{r nbclust_h2-hint-1}
enviro_scale <- ___(enviro)
factoextra::___(enviro_scale, kmeans, method = "wss")
#### ATTENTION: Hint suivant = solution !####
```

```{r nbclust_h2-solution}
enviro_scale <- scale(enviro)
factoextra::fviz_nbclust(enviro_scale, kmeans, method = "wss")
```

```{r nbclust_h2-check}
grade_code("Bravo ! Avec de ce graphique, vous avez un outils qui peut vous aider à déterminer le nombre de centres. Il vous montre la décroissance de la somme des carrés des distances intra-groupes en fonction du nombre de centre *k*. La valeur obtenue pour *k* = 1 nous indique de combien les données sont dispersées. En augmentant la valeur de *k*, l'objectif est de faire des regroupements pour diminuer la variance intra-groupe. Essayez maintenant de déterminer le nombre de centre en répondant à la question qui suit.")
```

```{r qu_nbclust}
question("Sur base du graphique que vous avez réalisé, combien de groupes réaliseriez vous ? (plusieurs réponses sont possibles) ",
           answer("1"),
           answer("2"),
           answer("3"),
           answer("4", correct = TRUE),
           answer("5"),
           answer("Plus de 5"), 
          allow_retry = TRUE,
         correct = "Bravo, vous avez trouvé la bonne réponse. L'objectif est de faire des regroupement qui diminuent la variance intra-groupe autant que possible, ce que nous notons par la diminution de la somme des carrés intra-groupes (*total within sum of square*). Sur ce graphique, on choisira une valeur de *k* à la base du coude, lorsque l'ajout d'un *k* supplémentaire ne permet plus de faire baisser *total within sum of square* de manière importante. Comme vous pouvez vous en rendre compte le nombre de groupe *k* proposé reste n'est qu'indicatif. D'autres informations que vous aurez en votre possession vous suggèreront peut-être un regroupement différent.",
         incorrect = "Retentez votre chance. Il y a une part de subjectivité dans l'analyse de ce graphique. Mais nous recherchons des sauts importants dans la décroissance de la somme des carrés (*total within sum of square*). L'objectif est de choisir la valeur de *k* à la base du coude, lorsque l'ajout d'un *k* supplémentaire ne permet plus de faire baisser la somme des carrés de manière importante.")
```

### Calcul des kmeans

Maintenant que vous avez défini la valeur de *k* que vous allez utiliser, vous pouvez procéder au calcul des k-moyennes en utilisant la fonction `kmeans()`. Vous lui fournirez le tableau de départ contenant uniquement des valeurs numériques éventuellement *standardisées* et spécifierez le nombre k de groupes souhaités via l’argument `centers =`. 

La position initiale des k centres est déterminée aléatoirement. Le résultat final peut donc varier et ne pas forcément être optimal. Pour éviter cela, nous pouvons utiliser l’argument `nstart =` qui testera différentes situations de départ pour conserver le meilleur résultat. Par défaut,une seule situation aléatoire de départ `nstart = 1` est considérée. En indiquant une valeur plus élevée, il est possible d’essayer plusieurs situations de départ. Votre analyse sera plus robuste et plus reproductible… mais cela augmentera le temps de calcul.

En utilisant le tableau standardisé mis à votre disposition et enregistré sous `enviro_scale`, réalisez un regroupement avec la fonction `kmeans()`. Utilisez pour cela une valeur k de 4 et 25 positions de départ différentes. 

```{r kmeans_prep}
enviro_scale <- as_tibble(scale(enviro))
```

```{r kmeans_h2, exercise=TRUE, exercise.setup="kmeans_prep"}
set.seed(210219) # comme un facteur aléatoire intervient, nous utilisons set.seed() pour rendre l’analyse reproductible.
(enviro_kmeans <- ___(___, ___ = ___, nstart = ___))
```

```{r kmeans_h2-hint-1}
set.seed(210219) # comme un facteur aléatoire intervient, nous utilisons set.seed() pour rendre l’analyse reproductible.
(enviro_kmeans <- ___(enviro_scale, ___ = 4, nstart = 25))

#### ATTENTION: Hint suivant = solution !####
```

```{r kmeans_h2-solution}
set.seed(210219) # comme un facteur aléatoire intervient, nous utilisons set.seed() pour rendre l’analyse reproductible.
(enviro_kmeans <- kmeans(enviro_scale, centers = 4, nstart = 25))
```

```{r kmeans_h2-check}
grade_code("Félicitation, vous venez de réaliser votre première classification par les k moyennes ! La sortie que vous obtenez est l'impression du contenu de l'objet kmeans qui vous donne beaucoup d'information. Pour commencer, vous avez le nombre de stations présentes dans chaque groupe (12, 10, 2 et 6). Ensuite, la section `Cluster means` reprend les positions des centres pour les 4 groupes que vous avez réalisé. Dans la section suivante, `Cluster vectors`, on vous spécifie l'appartenance aux groupes des stations. L'avant dernière section, `Within cluster sum of squares by cluster` vous donne une mesure de la qualité de regroupement de vos données, 69.3% ici. Plus cette valeur sera proche de 100% mieux ce sera ! Et finalement, vous avez les différents composant que vous pouvez obtenir en utilisant l'opérateur `$`.")
```

### Réalisation d'un graphique de regroupement

Maintenant que vous venez de réaliser vos regroupements avec la fonction `kmeans()`, vous avez la possibilité de les représenter sur un graphique. 

Pour cela, vous allez devoir collecter les groupes et les ajouter à votre tableau de données grâce à la fonction `augment()` du package `broom`. Il faudra lui renseigner l'objet kmeans que vous venez de calculer et le tableau de départ. Lors de cette étape, n'oubliez pas de renommer la colonne `.cluster` créée avec la fonction `augment()` en `cluster`. Prenez soin de placer vos données complétées avec la nouvelle variable `cluster` dans un tableau nommé différemment afin d'éviter des effets surprenants si vous relancer votre analyse. 

Si vous souhaitez représenter les centres sur votre graphique, vous pouvez facilement obtenir un tableau contenant les coordonnées des k centres en utilisant la fonction `tidy()` du package `broom`. N'oubliez pas d'utiliser l'argument `col.names = names(DF)` pour attribuer aux variables de votre tableau des centres le même nom que celles du tableau de départ. 

Vous avez à disposition le tableau de données `enviro_scale` et l'objet kmeans enregistré sous `enviro_kmeans`. 
Réaliser un graphique des nitrates en fonction de l'oxygène dissout. Regrouper les stations par de la couleur en utilisant les clusters que vous avez calculé et représentez les centres sur votre graphique.   

```{r graphe_prep}
enviro_scale <- as_tibble(scale(enviro))
set.seed(210219) 
enviro_kmeans <- kmeans(enviro_scale, centers = 4, nstart = 25)
```

```{r graphe_h3, exercise=TRUE, exercise.setup="graphe_prep"}
# ajouter les clusters au tableau de départ
broom::___(___, ___) %>.%
  rename(., cluster = ___) -> enviro2

# Créer le tableau des centres
(enviro_centers <- broom::___(___, col.names = names(___)))

# Graphique 
chart(data = ___ ,  ___ ~___) +
  ___() +
  # Représentation des centres 
  ___(data = ___, size = 5, shape = 17)
```

```{r graphe_h3-hint-1}
# ajouter les clusters au tableau de départ
broom::___(OBJ_KMEANS, ___) %>.%
  rename(., cluster = .cluster) -> enviro2

# Créer le tableau des centres
(enviro_centers <- broom::___(OBJ_KMEANS, col.names = names(___)))

# Graphique 
chart(data = enviro2, ___ ~ ___ %col=% ___) +
  geom_point() +
  # Représentation des centres 
  geom_point(data = ___, size = 5, shape = 17)
```

```{r graphe_h3-hint-2}
# ajouter les clusters au tableau de départ
broom::augment(enviro_kmeans, DF) %>.%
  rename(., cluster = .cluster) -> enviro2

# Créer le tableau des centres
(enviro_centers <- broom::___(enviro_kmeans, col.names = names(enviro_scale)))

# Graphique 
chart(data = enviro2, nit ~ oxy %col=% ___) +
  geom_point()+
  # Représentation des centres 
  geom_point(data = CENTERS, size = 5, shape = 17)

#### ATTENTION: Hint suivant = solution !####
```

```{r graphe_h3-solution}
# ajouter les clusters au tableau de départ
broom::augment(enviro_kmeans, enviro_scale) %>.%
  rename(., cluster = .cluster) -> enviro2

# Créer le tableau des centres
(enviro_centers <- broom::tidy(enviro_kmeans, col.names = names(enviro_scale)))

# Graphique 
chart(data = enviro2, nit ~ oxy %col=% cluster) +
  geom_point() +
  # Représentation des centres 
  geom_point(data = enviro_centers, size = 5, shape = 17)
```

```{r graphe_h3-check}
grade_code("Vous voyez comme c'est facile ! Grâce à la fonction `augment()`, vous avez pu ajouter les groupes formés à votre table de départ. La fonction `tidy()` vous a ensuite permis de récupérer les coordonnées de vos k centres. Et vous avez finalement pu utiliser ces informations sur un graphique ")
```

## Conclusion

Félicitation ! Vous venez de terminer votre auto-évaluation relative à la classification par les k-moyenne. Vous maitrisez maintenant les fonctions nécessaire pour la réalisation ce type de classification. 

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur cet outil pédagogique",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
